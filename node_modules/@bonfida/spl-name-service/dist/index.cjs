"use strict";var e=require("@solana/web3.js"),t=require("buffer"),r=require("@solana/spl-token"),i=require("bn.js"),a=require("borsh"),s=require("@bonfida/name-tokenizer"),n=require("@ethersproject/sha2"),o=require("@pythnetwork/client");function c(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var i=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var u=c(require("tweetnacl"));class p extends i{toBuffer(){const e=super.toArray().reverse(),r=t.Buffer.from(e);if(4===r.length)return r;if(r.length>4)throw new Error("Numberu32 too large");const i=t.Buffer.alloc(4);return r.copy(i),i}static fromBuffer(e){if(4!==e.length)throw new Error(`Invalid buffer length: ${e.length}`);return new i([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}}class l extends i{toBuffer(){const e=super.toArray().reverse(),r=t.Buffer.from(e);if(8===r.length)return r;if(r.length>8)throw new Error("Numberu64 too large");const i=t.Buffer.alloc(8);return r.copy(i),i}static fromBuffer(e){if(8!==e.length)throw new Error(`Invalid buffer length: ${e.length}`);return new i([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}}function f(r,i,a,s,n,o,c,u,l,f,d){const y=[t.Buffer.from(Int8Array.from([0])),new p(o.length).toBuffer(),o,c.toBuffer(),u.toBuffer()],w=t.Buffer.concat(y),g=[{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1}];return l?g.push({pubkey:l,isSigner:!0,isWritable:!1}):g.push({pubkey:new e.PublicKey(t.Buffer.alloc(32)),isSigner:!1,isWritable:!1}),f?g.push({pubkey:f,isSigner:!1,isWritable:!1}):g.push({pubkey:new e.PublicKey(t.Buffer.alloc(32)),isSigner:!1,isWritable:!1}),d&&g.push({pubkey:d,isSigner:!0,isWritable:!1}),new e.TransactionInstruction({keys:g,programId:r,data:w})}function d(r,i,a,s,n){const o=[t.Buffer.from(Int8Array.from([1])),a.toBuffer(),new p(s.length).toBuffer(),s],c=t.Buffer.concat(o),u=[{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new e.TransactionInstruction({keys:u,programId:r,data:c})}function y(r,i,a,s,n,o,c){const u=[t.Buffer.from(Int8Array.from([2])),a.toBuffer()],p=t.Buffer.concat(u),l=[{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:c||s,isSigner:!0,isWritable:!1}];return n&&l.push({pubkey:n,isSigner:!0,isWritable:!1}),c&&o&&(n||l.push({pubkey:e.PublicKey.default,isSigner:!1,isWritable:!1}),l.push({pubkey:o,isSigner:!1,isWritable:!1})),new e.TransactionInstruction({keys:l,programId:r,data:p})}function w(r,i,a,s){const n=[t.Buffer.from(Int8Array.from([3]))],o=t.Buffer.concat(n),c=[{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0}];return new e.TransactionInstruction({keys:c,programId:r,data:o})}class g{constructor(e){this.tag=9,this.name=e.name,this.space=e.space}serialize(){return a.serialize(g.schema,this)}getInstruction(i,a,s,n,o,c,u,p,l,f,d){const y=t.Buffer.from(this.serialize()),w=[{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:e.SystemProgram.programId,isSigner:!1,isWritable:!1},{pubkey:u,isSigner:!1,isWritable:!1},{pubkey:p,isSigner:!0,isWritable:!0},{pubkey:l,isSigner:!1,isWritable:!0},{pubkey:f,isSigner:!1,isWritable:!0},{pubkey:r.TOKEN_PROGRAM_ID,isSigner:!1,isWritable:!1},{pubkey:d,isSigner:!1,isWritable:!1}];return new e.TransactionInstruction({keys:w,programId:i,data:y})}}g.schema=new Map([[g,{kind:"struct",fields:[["tag","u8"],["name","string"],["space","u32"]]}]]);class m{constructor(e){this.tag=5,this.name=e.name}serialize(){return a.serialize(m.schema,this)}getInstruction(r,i,a,s,n,o,c,u,p){const l=t.Buffer.from(this.serialize());let f=[{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:e.PublicKey.default,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1},{pubkey:c,isSigner:!0,isWritable:!0}];if(u){if(!p)throw new Error("Missing parent name owner");f.push({pubkey:u,isSigner:!1,isWritable:!0}),f.push({pubkey:p,isSigner:!0,isWritable:!1})}return new e.TransactionInstruction({keys:f,programId:r,data:l})}}m.schema=new Map([[m,{kind:"struct",fields:[["tag","u8"],["name","string"]]}]]);class b{constructor(e){this.tag=13,this.name=e.name,this.space=e.space,this.referrerIdxOpt=e.referrerIdxOpt}serialize(){return a.serialize(b.schema,this)}getInstruction(r,i,a,s,n,o,c,u,p,l,f,d,y,w,g,m,b){const h=t.Buffer.from(this.serialize());let S=[];return S.push({pubkey:i,isSigner:!1,isWritable:!1}),S.push({pubkey:a,isSigner:!1,isWritable:!1}),S.push({pubkey:s,isSigner:!1,isWritable:!0}),S.push({pubkey:n,isSigner:!1,isWritable:!0}),S.push({pubkey:o,isSigner:!1,isWritable:!1}),S.push({pubkey:c,isSigner:!1,isWritable:!1}),S.push({pubkey:u,isSigner:!0,isWritable:!0}),S.push({pubkey:p,isSigner:!1,isWritable:!0}),S.push({pubkey:l,isSigner:!1,isWritable:!1}),S.push({pubkey:f,isSigner:!1,isWritable:!1}),S.push({pubkey:d,isSigner:!1,isWritable:!1}),S.push({pubkey:y,isSigner:!1,isWritable:!0}),S.push({pubkey:w,isSigner:!1,isWritable:!1}),S.push({pubkey:g,isSigner:!1,isWritable:!1}),S.push({pubkey:m,isSigner:!1,isWritable:!1}),b&&S.push({pubkey:b,isSigner:!1,isWritable:!0}),new e.TransactionInstruction({keys:S,programId:r,data:h})}}b.schema=new Map([[b,{kind:"struct",fields:[["tag","u8"],["name","string"],["space","u32"],["referrerIdxOpt",{kind:"option",type:"u16"}]]}]]);const h=new e.PublicKey("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"),S="SPL Name Service",R=new e.PublicKey("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx"),x=new e.PublicKey("jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR"),k=new e.PublicKey("ETp9eKXVv1dWwHSpsXRUuXHmw24PwRkttCGVgpZEY9zF"),v=new e.PublicKey("AUoZ3YAhV3b2rZeEH93UMZHXUZcTramBvb4d9YEVySkc"),B=new e.PublicKey("33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z"),E=new e.PublicKey("FvPH7PrVrLGKPfqaf3xJodFTjZriqrAXXLTVWEorTFBi"),P=new e.PublicKey("4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv"),A=new e.PublicKey("DmSyHDSM9eSLyvoLsPvDr5fRRFZ7Bfr3h3ULvWpgQaq7"),I=new e.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),K=[new e.PublicKey("3ogYncmMM5CmytsGCqKHydmXmKUZ6sGWvizkzqwT7zb1"),new e.PublicKey("DM1jJCkZZEwY5tmWbgvKRxsDFzXCdbfrYCCH1CtwguEs"),new e.PublicKey("ADCp4QXFajHrhy4f43pD6GJFtQLkdBY2mjS9DfCk7tNW")],T=new Map([["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v","USDC"],["Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB","USDT"],["So11111111111111111111111111111111111111112","SOL"],["EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp","FIDA"],["FeGn77dhg1KXRRFeSwwMiykZnZPw5JXW6naf2aQgZDQf","ETH"],["7i5KKsX2weiTkry7jA4ZwSuXGhs5eJBEjY8vVxR4pfRx","GMT"],["AFbX8oGjGpmVFywbVouvhQSRmiW2aR1mohfahi4Y2AdB","GST"],["mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So","MSOL"],["DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263","BONK"],["EPeUFDgHRxs9xxEPVaL6kfGQvCon7jmAWKVUHuux1Tpz","BAT"]]),W=new e.PublicKey("AHtgzX45WTKfkPG53L6WYhGEXwQkN1BVknET3sVsLL8J"),N=new e.PublicKey("GcWEQ9K78FV7LEHteFVciYApERk5YvQuFDQPk1yYJVXi"),D=e=>{const r=S+e,i=n.sha256(t.Buffer.from(r,"utf8")).slice(2);return t.Buffer.from(i,"hex")},_=(r,i,a)=>{const s=[r];i?s.push(i.toBuffer()):s.push(t.Buffer.alloc(32)),a?s.push(a.toBuffer()):s.push(t.Buffer.alloc(32));const[n]=e.PublicKey.findProgramAddressSync(s,h);return n};async function O(e,t){const r=D(t.toBase58()),a=_(r,B),{registry:s}=await G.retrieve(e,a);if(!s.data)throw new Error("Could not retrieve name data");const n=new i(s.data.slice(0,4),"le").toNumber();return s.data.slice(4,4+n).toString()}async function z(e,t){let r=[];for(let e of t){const t=D(e.toBase58()),i=_(t,B);r.push(i)}return(await G.retrieveBatch(e,r)).map((e=>{if(void 0===e||void 0===e.data)return;let t=new i(e.data.slice(0,4),"le").toNumber();return e.data.slice(4,4+t).toString()}))}const H=(e,t=R)=>{let r=D(e);return{pubkey:_(r,void 0,t),hashed:r}},M=(e,r=!1)=>{e.endsWith(".sol")&&(e=e.slice(0,-4));const i=e.split(".");if(2===i.length){const e=t.Buffer.from([r?1:0]).toString().concat(i[0]),{pubkey:a}=H(i[1]);return{...H(e,a),isSub:!0,parent:a}}if(3===i.length&&r){const{pubkey:e}=H(i[2]),{pubkey:r}=H("\0".concat(i[1]),e),a=t.Buffer.from([1]).toString();return{...H(a.concat(i[0]),r),isSub:!0,parent:e,isSubRecord:!0}}if(i.length>=3)throw new Error("Invalid derivation input");return{...H(e,R),isSub:!1,parent:void 0}};const F=async(t,i)=>{try{const[a]=await e.PublicKey.findProgramAddress([s.MINT_PREFIX,i.toBuffer()],s.NAME_TOKENIZER_ID);console.log("mint",a.toBase58());if("0"===(await r.getMint(t,a)).supply.toString())return;const n=[{memcmp:{offset:0,bytes:a.toBase58()}},{memcmp:{offset:64,bytes:"2"}},{dataSize:165}],o=await t.getProgramAccounts(r.TOKEN_PROGRAM_ID,{filters:n});if(1!=o.length)return;return new e.PublicKey(o[0].account.data.slice(32,64))}catch{return}},L=e=>[{memcmp:{offset:32,bytes:e}},{memcmp:{offset:64,bytes:"2"}}],C=async(e,t)=>{const i=[...L(t.toBase58()),{dataSize:165}],a=(await e.getProgramAccounts(r.TOKEN_PROGRAM_ID,{filters:i})).map((e=>r.AccountLayout.decode(e.account.data))).map((t=>(async(e,t)=>{const r=await s.getRecordFromMint(e,t.mint);if(1===r.length)return s.NftRecord.deserialize(r[0].account.data)})(e,t)));return(await Promise.all(a)).filter((e=>void 0!==e))};class G{constructor(t){this.parentName=new e.PublicKey(t.parentName),this.owner=new e.PublicKey(t.owner),this.class=new e.PublicKey(t.class)}static async retrieve(e,t){var r;const i=await e.getAccountInfo(t);if(!i)throw new Error("Invalid name account provided");let s=a.deserializeUnchecked(this.schema,G,i.data);s.data=null===(r=i.data)||void 0===r?void 0:r.slice(this.HEADER_LEN);return{registry:s,nftOwner:await F(e,t)}}static async _retrieveBatch(e,t){const r=await e.getMultipleAccountsInfo(t),i=e=>{if(!e)return;const t=a.deserializeUnchecked(this.schema,G,e);return t.data=null==e?void 0:e.slice(this.HEADER_LEN),t};return r.map((e=>i(null==e?void 0:e.data)))}static async retrieveBatch(e,t){let r=[];const i=[...t];for(;i.length>0;)r.push(...await this._retrieveBatch(e,i.splice(0,100)));return r}}G.HEADER_LEN=96,G.schema=new Map([[G,{kind:"struct",fields:[["parentName",[32]],["owner",[32]],["class",[32]]]}]]);class U{constructor(e){this.name=e.name,this.ticker=e.ticker,this.mint=e.mint,this.decimals=e.decimals,this.website=null==e?void 0:e.website,this.logoUri=null==e?void 0:e.logoUri}serialize(){return a.serialize(U.schema,this)}static deserialize(e){return a.deserializeUnchecked(U.schema,U,e)}}U.schema=new Map([[U,{kind:"struct",fields:[["name","string"],["ticker","string"],["mint",[32]],["decimals","u8"],["website",{kind:"option",type:"string"}],["logoUri",{kind:"option",type:"string"}]]}]]);class Y{constructor(e){this.mint=e.mint}serialize(){return a.serialize(Y.schema,this)}static deserialize(e){return a.deserializeUnchecked(Y.schema,Y,e)}}async function j(e,t){if(!await e.getAccountInfo(t))throw new Error("Unable to find the given account.");return G.retrieve(e,t)}async function V(e){const r=S+e,i=n.sha256(t.Buffer.from(r,"utf8")).slice(2);return t.Buffer.from(i,"hex")}async function q(r,i,a){const s=[r];i?s.push(i.toBuffer()):s.push(t.Buffer.alloc(32)),a?s.push(a.toBuffer()):s.push(t.Buffer.alloc(32));const[n]=await e.PublicKey.findProgramAddress(s,h);return n}Y.schema=new Map([[Y,{kind:"struct",fields:[["mint",[32]]]}]]);const X=async(e,t=R)=>{let r=await V(e);return{pubkey:await q(r,void 0,t),hashed:r}},Z=async(e,r=!1)=>{e.endsWith(".sol")&&(e=e.slice(0,-4));const i=e.split(".");if(2===i.length){const e=t.Buffer.from([r?1:0]).toString().concat(i[0]),{pubkey:a}=await X(i[1]);return{...await X(e,a),isSub:!0,parent:a}}if(3===i.length&&r){const{pubkey:e}=await X(i[2]),{pubkey:r}=await X("\0".concat(i[1]),e),a=t.Buffer.from([1]).toString();return{...await X(a.concat(i[0]),r),isSub:!0,parent:e,isSubRecord:!0}}if(i.length>=3)throw new Error("Invalid derivation input");return{...await X(e,R),isSub:!1,parent:void 0}};async function J(t,r,i,a,s,n,o,c){const u=await V(r),d=await q(u,o,c),y=n||await t.getMinimumBalanceForRentExemption(i);let w;if(c){const{registry:e}=await j(t,c);w=e.owner}return f(h,e.SystemProgram.programId,d,s,a,u,new l(y),new p(i),o,c,w)}async function Q(e,t,r,i,a){const s=await V(t),n=await q(s,i,a);let o;o=i||(await G.retrieve(e,n)).registry.owner;return w(h,n,r,o)}const $=async(t,r,i,a,s)=>{let[n]=await e.PublicKey.findProgramAddress([x.toBuffer()],x),o=await V(t.toBase58()),c=await q(o,n,a);return[[],[new m({name:r}).getInstruction(x,e.SYSVAR_RENT_PUBKEY,h,R,c,n,i,a,s)]]};class ee{constructor(e){this.twitterRegistryKey=e.twitterRegistryKey,this.twitterHandle=e.twitterHandle}static async retrieve(e,t){let r=await e.getAccountInfo(t,"processed");if(!r)throw new Error("Invalid reverse Twitter account provided");return a.deserializeUnchecked(this.schema,ee,r.data.slice(G.HEADER_LEN))}}async function te(r,i,s,n,o){const c=await V(n.toString()),u=await q(c,E,P);let y=a.serialize(ee.schema,new ee({twitterRegistryKey:s.toBytes(),twitterHandle:i}));return[f(h,e.SystemProgram.programId,u,n,o,c,new l(await r.getMinimumBalanceForRentExemption(y.length+G.HEADER_LEN)),new p(y.length),E,P,E),d(h,u,new p(0),t.Buffer.from(y),E)]}ee.schema=new Map([[ee,{kind:"struct",fields:[["twitterRegistryKey",[32]],["twitterHandle","string"]]}]]);const re=new e.PublicKey("6NSu2tci4apRKQtt257bAVcvqYjB3zV2H1dWo56vgpa6"),ie=async(e,t)=>{const r=await q(await V(t.toBase58()),void 0,re),{registry:i}=await G.retrieve(e,r);if(!i.data)throw new Error("Invalid account data");return U.deserialize(i.data)},ae=new e.PublicKey("85iDfUvr3HJyLM2zcq5BXSiDvUWfw6cSE1FfNBo8Ap29");class se{constructor(t){this.tag=t.tag,this.nameAccount=new e.PublicKey(t.nameAccount)}static deserialize(e){return a.deserialize(this.schema,se,e)}static async retrieve(e,t){const r=await e.getAccountInfo(t);if(!r||!r.data)throw new Error("Favourite domain not found");return this.deserialize(r.data)}static async getKey(r,i){return await e.PublicKey.findProgramAddress([t.Buffer.from("favourite_domain"),i.toBuffer()],r)}static getKeySync(r,i){return e.PublicKey.findProgramAddressSync([t.Buffer.from("favourite_domain"),i.toBuffer()],r)}}se.schema=new Map([[se,{kind:"struct",fields:[["tag","u8"],["nameAccount",[32]]]}]]);var ne;exports.Record=void 0,(ne=exports.Record||(exports.Record={})).IPFS="IPFS",ne.ARWV="ARWV",ne.SOL="SOL",ne.ETH="ETH",ne.BTC="BTC",ne.LTC="LTC",ne.DOGE="DOGE",ne.Email="email",ne.Url="url",ne.Discord="discord",ne.Github="github",ne.Reddit="reddit",ne.Twitter="twitter",ne.Telegram="telegram",ne.Pic="pic",ne.SHDW="SHDW",ne.POINT="POINT",ne.BSC="BSC",ne.Injective="INJ",ne.Backpack="backpack";const oe=e=>{if(!e)return;const t=Array.from(e);return t.length-1-t.reverse().findIndex((e=>0!==e))+1},ce=(e,t)=>{const{pubkey:r}=M(t+"."+e,!0);return r},ue=async(e,t,r)=>{var i;const a=ce(t,r);let{registry:s}=await G.retrieve(e,a);const n=r===exports.Record.SOL?96:oe(s.data);return s.data=null===(i=s.data)||void 0===i?void 0:i.slice(0,n),s},pe=async(e,t)=>await ue(e,t,exports.Record.SOL),le=(e,t,r)=>u.sign.detached.verify(e,t,r.toBytes());exports.BONFIDA_FIDA_BNB=v,exports.BONFIDA_USDC_BNB=A,exports.FavouriteDomain=se,exports.HASH_PREFIX=S,exports.Mint=Y,exports.NAME_OFFERS_ID=ae,exports.NAME_PROGRAM_ID=h,exports.NameRegistryState=G,exports.Numberu32=p,exports.Numberu64=l,exports.PYTH_FIDA_PRICE_ACC=k,exports.PYTH_MAPPING_ACC=W,exports.REFERRERS=K,exports.REGISTER_PROGRAM_ID=x,exports.REVERSE_LOOKUP_CLASS=B,exports.ROOT_DOMAIN_ACCOUNT=R,exports.ReverseTwitterRegistryState=ee,exports.SOL_RECORD_SIG_LEN=96,exports.TOKENS_SYM_MINT=T,exports.TOKEN_TLD=re,exports.TWITTER_ROOT_PARENT_REGISTRY_KEY=P,exports.TWITTER_VERIFICATION_AUTHORITY=E,exports.TokenData=U,exports.USDC_MINT=I,exports.VAULT_OWNER=N,exports.changeTwitterRegistryData=async function(e,t,r,i){const a=await V(e),s=await q(a,void 0,P);return[d(h,s,new p(r),i,t)]},exports.changeVerifiedPubkey=async function(e,t,r,i,a){const s=await V(t),n=await q(s,void 0,P);let o=[y(h,n,i,r,void 0)];const c=await V(r.toString());return await q(c,E,void 0),o.push(await Q(e,r.toString(),a,E,P)),o=o.concat(await te(e,t,n,i,a)),o},exports.checkSolRecord=le,exports.createInstruction=f,exports.createInstructionV3=b,exports.createNameRegistry=J,exports.createReverseInstruction=m,exports.createReverseName=$,exports.createReverseTwitterRegistry=te,exports.createSubdomain=async(e,t,r,i=2e3)=>{const a=[],s=t.split(".")[0];if(!s)throw new Error("Invalid subdomain input");const{parent:n,pubkey:o}=M(t),c=await e.getMinimumBalanceForRentExemption(i+G.HEADER_LEN),u=await J(e,"\0".concat(s),i,r,r,c,void 0,n);a.push(u);const[,p]=await $(o,"\0".concat(s),r,n,r);return a.push(...p),[[],a]},exports.createV2Instruction=g,exports.createVerifiedTwitterRegistry=async function(t,r,i,a,s){const n=await V(r),o=await q(n,void 0,P),c=await t.getMinimumBalanceForRentExemption(a+G.HEADER_LEN);let u=[f(h,e.SystemProgram.programId,o,i,s,n,new l(c),new p(a),void 0,P,E)];return u=u.concat(await te(t,r,o,i,s)),u},exports.deleteInstruction=w,exports.deleteNameRegistry=Q,exports.deleteTwitterRegistry=async function(e,t){const r=await V(e),i=await q(r,void 0,P),a=await V(t.toString()),s=await q(a,E,P);return[w(h,i,t,t),w(h,s,t,t)]},exports.findSubdomains=async(e,t)=>{const r=[{memcmp:{offset:0,bytes:t.toBase58()}},{memcmp:{offset:64,bytes:B.toBase58()}}],i=await e.getProgramAccounts(h,{filters:r}),a=await O(e,t),s=i.map((e=>{var t;return null===(t=e.account.data.slice(97).toString("utf-8"))||void 0===t?void 0:t.split("\0").join("")})),n=s.map((e=>M(e+"."+a).pubkey)),o=await e.getMultipleAccountsInfo(n);return s.filter(((e,t)=>!!o[t]))},exports.getAllDomains=async function(e,t){const r=[{memcmp:{offset:32,bytes:t.toBase58()}},{memcmp:{offset:0,bytes:R.toBase58()}}];return(await e.getProgramAccounts(h,{filters:r})).map((e=>e.pubkey))},exports.getAllRegisteredDomains=async e=>{const t=[{memcmp:{offset:0,bytes:R.toBase58()}}];return await e.getProgramAccounts(h,{dataSlice:{offset:32,length:32},filters:t})},exports.getArweaveRecord=async(e,t)=>await ue(e,t,exports.Record.ARWV),exports.getBackpackRecord=async(e,t)=>await ue(e,t,exports.Record.Backpack),exports.getBscRecord=async(e,t)=>await ue(e,t,exports.Record.BSC),exports.getBtcRecord=async(e,t)=>await ue(e,t,exports.Record.BTC),exports.getDiscordRecord=async(e,t)=>await ue(e,t,exports.Record.Discord),exports.getDogeRecord=async(e,t)=>await ue(e,t,exports.Record.DOGE),exports.getDomainKey=Z,exports.getDomainKeySync=M,exports.getEmailRecord=async(e,t)=>await ue(e,t,exports.Record.Email),exports.getEthRecord=async(e,t)=>await ue(e,t,exports.Record.ETH),exports.getFavoriteDomain=async(t,r)=>{const[i]=se.getKeySync(ae,new e.PublicKey(r)),a=await se.retrieve(t,i),s=await O(t,a.nameAccount);return{domain:a.nameAccount,reverse:s}},exports.getGithubRecord=async(e,t)=>await ue(e,t,exports.Record.Github),exports.getHandleAndRegistryKey=async function(t,r){const i=await V(r.toString()),a=await q(i,E,P);let s=await ee.retrieve(t,a);return[s.twitterHandle,new e.PublicKey(s.twitterRegistryKey)]},exports.getHashedName=V,exports.getHashedNameSync=D,exports.getInjectiveRecord=async(e,t)=>await ue(e,t,exports.Record.Injective),exports.getIpfsRecord=async(e,t)=>await ue(e,t,exports.Record.IPFS),exports.getLtcRecord=async(e,t)=>await ue(e,t,exports.Record.LTC),exports.getNameAccountKey=q,exports.getNameAccountKeySync=_,exports.getNameOwner=j,exports.getPicRecord=async(e,t)=>await ue(e,t,exports.Record.Pic),exports.getPointRecord=async(e,t)=>await ue(e,t,exports.Record.POINT),exports.getRecord=ue,exports.getRecordKeySync=ce,exports.getRecords=async(e,t,r)=>{const i=r.map((e=>ce(t,e)));return(await G.retrieveBatch(e,i)).map(((e,t)=>{var i;if(!e)return;const a=r[t]===exports.Record.SOL?96:oe(e.data);return e.data=null===(i=null==e?void 0:e.data)||void 0===i?void 0:i.slice(0,a),e}))},exports.getRedditRecord=async(e,t)=>await ue(e,t,exports.Record.Reddit),exports.getReverseKey=async(e,t)=>{const{pubkey:r,parent:i}=await Z(e),a=await V(r.toBase58());return await q(a,B,t?i:void 0)},exports.getReverseKeySync=(e,t)=>{const{pubkey:r,parent:i}=M(e),a=D(r.toBase58());return _(a,B,t?i:void 0)},exports.getShdwRecord=async(e,t)=>await ue(e,t,exports.Record.SHDW),exports.getSolRecord=pe,exports.getTelegramRecord=async(e,t)=>await ue(e,t,exports.Record.Telegram),exports.getTokenInfoFromMint=ie,exports.getTokenInfoFromName=async(t,r)=>{const i=await q(await V(r),void 0,re),{registry:a}=await G.retrieve(t,i);if(!a.data)throw new Error("Invalid account data");const s=new e.PublicKey(Y.deserialize(a.data).mint);return await ie(t,s)},exports.getTokenizedDomains=async(e,t)=>{const r=await C(e,t);return(await z(e,r.map((e=>e.nameAccount)))).map(((e,t)=>({key:r[t].nameAccount,mint:r[t].nftMint,reverse:e}))).filter((e=>!!e.reverse))},exports.getTwitterHandleandRegistryKeyViaFilters=async function(t,r){const i=[{memcmp:{offset:0,bytes:P.toBase58()}},{memcmp:{offset:32,bytes:r.toBase58()}},{memcmp:{offset:64,bytes:E.toBase58()}}],s=await t.getProgramAccounts(h,{filters:i});for(const t of s)if(t.account.data.length>G.HEADER_LEN+32){let r=t.account.data.slice(G.HEADER_LEN),i=a.deserializeUnchecked(ee.schema,ee,r);return[i.twitterHandle,new e.PublicKey(i.twitterRegistryKey)]}throw new Error("Registry not found.")},exports.getTwitterRecord=async(e,t)=>await ue(e,t,exports.Record.Twitter),exports.getTwitterRegistry=async function(e,t){const r=await V(t),i=await q(r,void 0,P),{registry:a}=await G.retrieve(e,i);return a},exports.getTwitterRegistryData=async function(r,i){const a=[{memcmp:{offset:0,bytes:P.toBase58()}},{memcmp:{offset:32,bytes:i.toBase58()}},{memcmp:{offset:64,bytes:new e.PublicKey(t.Buffer.alloc(32,0)).toBase58()}}],s=await r.getProgramAccounts(h,{filters:a});if(s.length>1)throw new Error("Found more than one registry.");return s[0].account.data.slice(G.HEADER_LEN)},exports.getTwitterRegistryKey=async function(e){const t=await V(e);return await q(t,void 0,P)},exports.getUrlRecord=async(e,t)=>await ue(e,t,exports.Record.Url),exports.performReverseLookup=async function(e,t){const r=await V(t.toBase58()),a=await q(r,B),{registry:s}=await G.retrieve(e,a);if(!s.data)throw new Error("Could not retrieve name data");const n=new i(s.data.slice(0,4),"le").toNumber();return s.data.slice(4,4+n).toString()},exports.performReverseLookupBatch=async function(e,t){let r=[];for(let e of t){const t=await V(e.toBase58()),i=await q(t,B);r.push(i)}return(await G.retrieveBatch(e,r)).map((e=>{if(void 0===e||void 0===e.data)return;let t=new i(e.data.slice(0,4),"le").toNumber();return e.data.slice(4,4+t).toString()}))},exports.registerDomainName=async(t,i,a,s,n,c=I,u)=>{const[p]=e.PublicKey.findProgramAddressSync([x.toBuffer()],x),l=D(i),f=_(l,void 0,R),d=D(f.toBase58()),y=_(d,p),[w]=e.PublicKey.findProgramAddressSync([f.toBuffer()],x),g=K.findIndex((e=>null==u?void 0:u.equals(e)));let m;const S=[];if(-1!==g&&u){m=r.getAssociatedTokenAddressSync(c,u,!0);const e=await t.getAccountInfo(m);if(!(null==e?void 0:e.data)){const e=r.createAssociatedTokenAccountInstruction(s,m,u,c);S.push(e)}}const k=new o.PythHttpClient(t,o.getPythProgramKeyForCluster("mainnet-beta")),v=await k.getData(),B=T.get(c.toBase58());if(!B)throw new Error("Symbol not found");const E=v.productPrice.get("Crypto."+B+"/USD"),P=v.productFromSymbol.get("Crypto."+B+"/USD"),A=r.getAssociatedTokenAddressSync(c,N),O=new b({name:i,space:a,referrerIdxOpt:-1!=g?g:null}).getInstruction(x,h,R,f,y,e.SystemProgram.programId,p,s,n,W,E.productAccountKey,new e.PublicKey(P.price_account),A,r.TOKEN_PROGRAM_ID,e.SYSVAR_RENT_PUBKEY,w,m);return S.push(O),[[],S]},exports.resolve=async(r,i)=>{const{pubkey:a}=M(i),{registry:s,nftOwner:n}=await G.retrieve(r,a);if(n)return n;try{const a=M(exports.Record.SOL+"."+i,!0),n=await pe(r,i);if(!n.data)throw new Error("Invalid SOL record data");const o=new TextEncoder,c=t.Buffer.concat([n.data.slice(0,32),a.pubkey.toBuffer()]),u=o.encode(c.toString("hex"));if(!le(u,n.data.slice(32),s.owner))throw new Error("Signature invalid");return new e.PublicKey(n.data.slice(0,32))}catch(e){if(e instanceof Error&&"FetchError"===e.name)throw e;console.log(e)}return s.owner},exports.retrieveNftOwner=F,exports.retrieveNfts=async t=>{const r=await t.getProgramAccounts(s.NAME_TOKENIZER_ID,{filters:[{memcmp:{offset:0,bytes:"3"}}]});return r.map((t=>new e.PublicKey(t.account.data.slice(66,98))))},exports.reverseLookup=O,exports.reverseLookupBatch=z,exports.transferInstruction=y,exports.transferNameOwnership=async function(e,t,r,i,a,s){const n=await V(t),o=await q(n,i,a);let c;return c=i||(await G.retrieve(e,o)).registry.owner,y(h,o,r,c,i,a,s)},exports.updateInstruction=d,exports.updateNameRegistryData=async function(e,t,r,i,a,s){const n=await V(t),o=await q(n,a,s);let c;return c=a||(await G.retrieve(e,o)).registry.owner,d(h,o,new p(r),i,c)};
