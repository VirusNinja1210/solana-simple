import{TransactionInstruction as e,PublicKey as i,SystemProgram as s,SYSVAR_RENT_PUBKEY as r}from"@solana/web3.js";import{serialize as t,deserialize as a}from"borsh";import{Buffer as n}from"buffer";import{TOKEN_PROGRAM_ID as u,getAssociatedTokenAddress as o,ASSOCIATED_TOKEN_PROGRAM_ID as p}from"@solana/spl-token";import{NAME_PROGRAM_ID as b}from"@bonfida/spl-name-service";class c{constructor(){this.tag=1}serialize(){return t(c.schema,this)}getInstruction(i,s,r,t,a,u,o,p,b,c,g,f,l){const h=n.from(this.serialize());let m=[];return m.push({pubkey:s,isSigner:!1,isWritable:!0}),m.push({pubkey:r,isSigner:!1,isWritable:!0}),m.push({pubkey:t,isSigner:!1,isWritable:!0}),m.push({pubkey:a,isSigner:!1,isWritable:!1}),m.push({pubkey:u,isSigner:!1,isWritable:!0}),m.push({pubkey:o,isSigner:!1,isWritable:!1}),m.push({pubkey:p,isSigner:!1,isWritable:!1}),m.push({pubkey:b,isSigner:!1,isWritable:!1}),m.push({pubkey:c,isSigner:!1,isWritable:!1}),m.push({pubkey:g,isSigner:!1,isWritable:!1}),m.push({pubkey:f,isSigner:!1,isWritable:!1}),m.push({pubkey:l,isSigner:!1,isWritable:!1}),new e({keys:m,programId:i,data:h})}}c.schema=new Map([[c,{kind:"struct",fields:[["tag","u8"]]}]]);class g{constructor(){this.tag=0}serialize(){return t(g.schema,this)}getInstruction(i,s,r,t,a,u,o,p){const b=n.from(this.serialize());let c=[];return c.push({pubkey:s,isSigner:!1,isWritable:!0}),c.push({pubkey:r,isSigner:!1,isWritable:!0}),c.push({pubkey:t,isSigner:!1,isWritable:!1}),c.push({pubkey:a,isSigner:!1,isWritable:!1}),c.push({pubkey:u,isSigner:!1,isWritable:!1}),c.push({pubkey:o,isSigner:!1,isWritable:!1}),c.push({pubkey:p,isSigner:!1,isWritable:!1}),new e({keys:c,programId:i,data:b})}}g.schema=new Map([[g,{kind:"struct",fields:[["tag","u8"]]}]]);class f{constructor(e){this.tag=2,this.name=e.name,this.uri=e.uri}serialize(){return t(f.schema,this)}getInstruction(i,s,r,t,a,u,o,p,b,c,g,f,l,h,m,d,y,k){const S=n.from(this.serialize());let W=[];return W.push({pubkey:s,isSigner:!1,isWritable:!0}),W.push({pubkey:r,isSigner:!1,isWritable:!0}),W.push({pubkey:t,isSigner:!1,isWritable:!0}),W.push({pubkey:a,isSigner:!1,isWritable:!0}),W.push({pubkey:u,isSigner:!0,isWritable:!0}),W.push({pubkey:o,isSigner:!1,isWritable:!0}),W.push({pubkey:p,isSigner:!1,isWritable:!1}),W.push({pubkey:b,isSigner:!1,isWritable:!1}),W.push({pubkey:c,isSigner:!1,isWritable:!1}),W.push({pubkey:g,isSigner:!1,isWritable:!0}),W.push({pubkey:f,isSigner:!0,isWritable:!0}),W.push({pubkey:l,isSigner:!1,isWritable:!1}),W.push({pubkey:h,isSigner:!1,isWritable:!1}),W.push({pubkey:m,isSigner:!1,isWritable:!1}),W.push({pubkey:d,isSigner:!1,isWritable:!1}),W.push({pubkey:y,isSigner:!1,isWritable:!1}),W.push({pubkey:k,isSigner:!0,isWritable:!1}),new e({keys:W,programId:i,data:S})}}f.schema=new Map([[f,{kind:"struct",fields:[["tag","u8"],["name","string"],["uri","string"]]}]]);class l{constructor(){this.tag=3}serialize(){return t(l.schema,this)}getInstruction(i,s,r,t,a,u,o,p){const b=n.from(this.serialize());let c=[];return c.push({pubkey:s,isSigner:!1,isWritable:!0}),c.push({pubkey:r,isSigner:!1,isWritable:!0}),c.push({pubkey:t,isSigner:!0,isWritable:!0}),c.push({pubkey:a,isSigner:!1,isWritable:!0}),c.push({pubkey:u,isSigner:!1,isWritable:!0}),c.push({pubkey:o,isSigner:!1,isWritable:!1}),c.push({pubkey:p,isSigner:!1,isWritable:!1}),new e({keys:c,programId:i,data:b})}}l.schema=new Map([[l,{kind:"struct",fields:[["tag","u8"]]}]]);class h{constructor(){this.tag=4}serialize(){return t(h.schema,this)}getInstruction(i,s,r,t,a,u,o,p){const b=n.from(this.serialize());let c=[];return c.push({pubkey:s,isSigner:!1,isWritable:!0}),c.push({pubkey:r,isSigner:!0,isWritable:!0}),c.push({pubkey:t,isSigner:!1,isWritable:!0}),c.push({pubkey:a,isSigner:!1,isWritable:!0}),c.push({pubkey:u,isSigner:!1,isWritable:!0}),c.push({pubkey:o,isSigner:!1,isWritable:!1}),c.push({pubkey:p,isSigner:!1,isWritable:!1}),new e({keys:c,programId:i,data:b})}}h.schema=new Map([[h,{kind:"struct",fields:[["tag","u8"]]}]]);class m{constructor(e){this.tag=5,this.offset=e.offset,this.data=e.data}serialize(){return t(m.schema,this)}getInstruction(i,s,r,t,a,u,o){const p=n.from(this.serialize());let b=[];return b.push({pubkey:s,isSigner:!0,isWritable:!1}),b.push({pubkey:r,isSigner:!1,isWritable:!1}),b.push({pubkey:t,isSigner:!1,isWritable:!1}),b.push({pubkey:a,isSigner:!1,isWritable:!0}),b.push({pubkey:u,isSigner:!1,isWritable:!1}),b.push({pubkey:o,isSigner:!1,isWritable:!1}),new e({keys:b,programId:i,data:p})}}m.schema=new Map([[m,{kind:"struct",fields:[["tag","u8"],["offset","u32"],["data",["u8"]]]}]]);const d=n.from("tokenized_name"),y=n.from("collection"),k=new i("ARy9ZzW9qFCb8c8Lxi4NCph1TRNabUaMH5tj4e5pqwHb");var S;!function(e){e[e.Uninitialized=0]="Uninitialized",e[e.CentralState=1]="CentralState",e[e.ActiveRecord=2]="ActiveRecord",e[e.InactiveRecord=3]="InactiveRecord"}(S||(S={}));class W{constructor(e){this.tag=e.tag,this.nonce=e.nonce,this.nameAccount=new i(e.nameAccount),this.owner=new i(e.owner),this.nftMint=new i(e.nftMint)}static deserialize(e){return a(this.schema,W,e)}static async retrieve(e,i){const s=await e.getAccountInfo(i);if(!s||!s.data)throw new Error("NFT record not found");return this.deserialize(s.data)}static async findKey(e,s){return await i.findProgramAddress([n.from("nft_record"),e.toBuffer()],s)}}W.schema=new Map([[W,{kind:"struct",fields:[["tag","u8"],["nonce","u8"],["nameAccount",[32]],["owner",[32]],["nftMint",[32]]]}]]);const w=new i("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),A="metadata",I=e=>i.findProgramAddressSync([n.from(A),w.toBuffer(),e.toBuffer()],w)[0],z=e=>i.findProgramAddressSync([n.from(A),w.toBuffer(),e.toBuffer(),n.from("edition")],w)[0],B=new i("nftD3vbNkNqfj2Sd3HZwbpw4BxxKWr4AjGb9X38JeZk"),P=new i("45gRSRZmK6NDEJrCZ72MMddjA1ozufq9YQpm41poPXCE"),M=async(e,t,a)=>{const[n]=await i.findProgramAddress([a.toBuffer()],a),[o]=await i.findProgramAddress([d,e.toBuffer()],a);return[(new g).getInstruction(a,o,e,n,u,s.programId,r,t)]},v=async(e,t)=>{const[a]=await i.findProgramAddress([t.toBuffer()],t),[n]=await i.findProgramAddress([y,t.toBuffer()],t),g=I(n),f=z(n),l=await o(n,a,!0);return[(new c).getInstruction(t,n,f,g,a,l,e,u,w,s.programId,b,p,r)]},R=async(e,t,a,p,c,g)=>{const[l]=await i.findProgramAddress([g.toBuffer()],g),[h]=await i.findProgramAddress([d,a.toBuffer()],g),[m]=await W.findKey(a,g),S=await o(h,p),B=I(h),[P]=await i.findProgramAddress([y,g.toBuffer()],g),[M]=i.findProgramAddressSync([n.from(A),w.toBuffer(),P.toBuffer()],w),v=z(P);return[new f({name:e,uri:t}).getInstruction(g,h,S,a,m,p,B,v,M,P,l,c,u,w,s.programId,b,r,k)]},j=async(e,s,r)=>{const[t]=await i.findProgramAddress([d,e.toBuffer()],r),[a]=await W.findKey(e,r),n=await o(t,s);return[(new l).getInstruction(r,t,n,s,a,e,u,b)]},x=async(e,i,r,t,a)=>{const n=await o(i,r),p=await o(i,t,!0),b=await o(e,r);return[(new h).getInstruction(a,b,r,t,n,p,u,s.programId)]},q=async(e,i)=>{const s=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:34,bytes:i.toBase58()}}];return await e.getProgramAccounts(B,{filters:s})},C=async(e,i)=>{const s=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:2,bytes:i.toBase58()}}];return await e.getProgramAccounts(B,{filters:s})},N=async(e,i)=>{const s=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:66,bytes:i.toBase58()}}];return await e.getProgramAccounts(B,{filters:s})},K=async e=>await e.getProgramAccounts(B,{filters:[{memcmp:{offset:0,bytes:"3"}}]}),Z=e=>{const[s]=i.findProgramAddressSync([d,e.toBuffer()],B);return s},U=async(e,i)=>{const s=Z(i);return 1===(await e.getTokenSupply(s)).value.uiAmount};export{y as COLLECTION_PREFIX,k as METADATA_SIGNER,d as MINT_PREFIX,B as NAME_TOKENIZER_ID,P as NAME_TOKENIZER_ID_DEVNET,W as NftRecord,S as Tag,v as createCollection,c as createCollectionInstruction,M as createMint,g as createMintInstruction,R as createNft,f as createNftInstruction,m as editDataInstruction,K as getActiveRecords,z as getMasterEditionPda,I as getMetadataPda,Z as getMint,C as getMintFromNameAccount,q as getNftForOwner,N as getRecordFromMint,U as isTokenized,j as redeemNft,l as redeemNftInstruction,x as withdrawTokens,h as withdrawTokensInstruction};
