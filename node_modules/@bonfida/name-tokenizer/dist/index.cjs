"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@solana/web3.js"),s=require("borsh"),i=require("buffer"),t=require("@solana/spl-token"),r=require("@bonfida/spl-name-service");class a{constructor(){this.tag=1}serialize(){return s.serialize(a.schema,this)}getInstruction(s,t,r,a,n,u,o,c,p,b,l,f,g){const d=i.Buffer.from(this.serialize());let y=[];return y.push({pubkey:t,isSigner:!1,isWritable:!0}),y.push({pubkey:r,isSigner:!1,isWritable:!0}),y.push({pubkey:a,isSigner:!1,isWritable:!0}),y.push({pubkey:n,isSigner:!1,isWritable:!1}),y.push({pubkey:u,isSigner:!1,isWritable:!0}),y.push({pubkey:o,isSigner:!1,isWritable:!1}),y.push({pubkey:c,isSigner:!1,isWritable:!1}),y.push({pubkey:p,isSigner:!1,isWritable:!1}),y.push({pubkey:b,isSigner:!1,isWritable:!1}),y.push({pubkey:l,isSigner:!1,isWritable:!1}),y.push({pubkey:f,isSigner:!1,isWritable:!1}),y.push({pubkey:g,isSigner:!1,isWritable:!1}),new e.TransactionInstruction({keys:y,programId:s,data:d})}}a.schema=new Map([[a,{kind:"struct",fields:[["tag","u8"]]}]]);class n{constructor(){this.tag=0}serialize(){return s.serialize(n.schema,this)}getInstruction(s,t,r,a,n,u,o,c){const p=i.Buffer.from(this.serialize());let b=[];return b.push({pubkey:t,isSigner:!1,isWritable:!0}),b.push({pubkey:r,isSigner:!1,isWritable:!0}),b.push({pubkey:a,isSigner:!1,isWritable:!1}),b.push({pubkey:n,isSigner:!1,isWritable:!1}),b.push({pubkey:u,isSigner:!1,isWritable:!1}),b.push({pubkey:o,isSigner:!1,isWritable:!1}),b.push({pubkey:c,isSigner:!1,isWritable:!1}),new e.TransactionInstruction({keys:b,programId:s,data:p})}}n.schema=new Map([[n,{kind:"struct",fields:[["tag","u8"]]}]]);class u{constructor(e){this.tag=2,this.name=e.name,this.uri=e.uri}serialize(){return s.serialize(u.schema,this)}getInstruction(s,t,r,a,n,u,o,c,p,b,l,f,g,d,y,h,m,k){const S=i.Buffer.from(this.serialize());let A=[];return A.push({pubkey:t,isSigner:!1,isWritable:!0}),A.push({pubkey:r,isSigner:!1,isWritable:!0}),A.push({pubkey:a,isSigner:!1,isWritable:!0}),A.push({pubkey:n,isSigner:!1,isWritable:!0}),A.push({pubkey:u,isSigner:!0,isWritable:!0}),A.push({pubkey:o,isSigner:!1,isWritable:!0}),A.push({pubkey:c,isSigner:!1,isWritable:!1}),A.push({pubkey:p,isSigner:!1,isWritable:!1}),A.push({pubkey:b,isSigner:!1,isWritable:!1}),A.push({pubkey:l,isSigner:!1,isWritable:!0}),A.push({pubkey:f,isSigner:!0,isWritable:!0}),A.push({pubkey:g,isSigner:!1,isWritable:!1}),A.push({pubkey:d,isSigner:!1,isWritable:!1}),A.push({pubkey:y,isSigner:!1,isWritable:!1}),A.push({pubkey:h,isSigner:!1,isWritable:!1}),A.push({pubkey:m,isSigner:!1,isWritable:!1}),A.push({pubkey:k,isSigner:!0,isWritable:!1}),new e.TransactionInstruction({keys:A,programId:s,data:S})}}u.schema=new Map([[u,{kind:"struct",fields:[["tag","u8"],["name","string"],["uri","string"]]}]]);class o{constructor(){this.tag=3}serialize(){return s.serialize(o.schema,this)}getInstruction(s,t,r,a,n,u,o,c){const p=i.Buffer.from(this.serialize());let b=[];return b.push({pubkey:t,isSigner:!1,isWritable:!0}),b.push({pubkey:r,isSigner:!1,isWritable:!0}),b.push({pubkey:a,isSigner:!0,isWritable:!0}),b.push({pubkey:n,isSigner:!1,isWritable:!0}),b.push({pubkey:u,isSigner:!1,isWritable:!0}),b.push({pubkey:o,isSigner:!1,isWritable:!1}),b.push({pubkey:c,isSigner:!1,isWritable:!1}),new e.TransactionInstruction({keys:b,programId:s,data:p})}}o.schema=new Map([[o,{kind:"struct",fields:[["tag","u8"]]}]]);class c{constructor(){this.tag=4}serialize(){return s.serialize(c.schema,this)}getInstruction(s,t,r,a,n,u,o,c){const p=i.Buffer.from(this.serialize());let b=[];return b.push({pubkey:t,isSigner:!1,isWritable:!0}),b.push({pubkey:r,isSigner:!0,isWritable:!0}),b.push({pubkey:a,isSigner:!1,isWritable:!0}),b.push({pubkey:n,isSigner:!1,isWritable:!0}),b.push({pubkey:u,isSigner:!1,isWritable:!0}),b.push({pubkey:o,isSigner:!1,isWritable:!1}),b.push({pubkey:c,isSigner:!1,isWritable:!1}),new e.TransactionInstruction({keys:b,programId:s,data:p})}}c.schema=new Map([[c,{kind:"struct",fields:[["tag","u8"]]}]]);class p{constructor(e){this.tag=5,this.offset=e.offset,this.data=e.data}serialize(){return s.serialize(p.schema,this)}getInstruction(s,t,r,a,n,u,o){const c=i.Buffer.from(this.serialize());let p=[];return p.push({pubkey:t,isSigner:!0,isWritable:!1}),p.push({pubkey:r,isSigner:!1,isWritable:!1}),p.push({pubkey:a,isSigner:!1,isWritable:!1}),p.push({pubkey:n,isSigner:!1,isWritable:!0}),p.push({pubkey:u,isSigner:!1,isWritable:!1}),p.push({pubkey:o,isSigner:!1,isWritable:!1}),new e.TransactionInstruction({keys:p,programId:s,data:c})}}p.schema=new Map([[p,{kind:"struct",fields:[["tag","u8"],["offset","u32"],["data",["u8"]]]}]]);const b=i.Buffer.from("tokenized_name"),l=i.Buffer.from("collection"),f=new e.PublicKey("ARy9ZzW9qFCb8c8Lxi4NCph1TRNabUaMH5tj4e5pqwHb");var g;exports.Tag=void 0,(g=exports.Tag||(exports.Tag={}))[g.Uninitialized=0]="Uninitialized",g[g.CentralState=1]="CentralState",g[g.ActiveRecord=2]="ActiveRecord",g[g.InactiveRecord=3]="InactiveRecord";class d{constructor(s){this.tag=s.tag,this.nonce=s.nonce,this.nameAccount=new e.PublicKey(s.nameAccount),this.owner=new e.PublicKey(s.owner),this.nftMint=new e.PublicKey(s.nftMint)}static deserialize(e){return s.deserialize(this.schema,d,e)}static async retrieve(e,s){const i=await e.getAccountInfo(s);if(!i||!i.data)throw new Error("NFT record not found");return this.deserialize(i.data)}static async findKey(s,t){return await e.PublicKey.findProgramAddress([i.Buffer.from("nft_record"),s.toBuffer()],t)}}d.schema=new Map([[d,{kind:"struct",fields:[["tag","u8"],["nonce","u8"],["nameAccount",[32]],["owner",[32]],["nftMint",[32]]]}]]);const y=new e.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"),h="metadata",m=s=>e.PublicKey.findProgramAddressSync([i.Buffer.from(h),y.toBuffer(),s.toBuffer()],y)[0],k=s=>e.PublicKey.findProgramAddressSync([i.Buffer.from(h),y.toBuffer(),s.toBuffer(),i.Buffer.from("edition")],y)[0],S=new e.PublicKey("nftD3vbNkNqfj2Sd3HZwbpw4BxxKWr4AjGb9X38JeZk"),A=new e.PublicKey("45gRSRZmK6NDEJrCZ72MMddjA1ozufq9YQpm41poPXCE"),w=s=>{const[i]=e.PublicKey.findProgramAddressSync([b,s.toBuffer()],S);return i};exports.COLLECTION_PREFIX=l,exports.METADATA_SIGNER=f,exports.MINT_PREFIX=b,exports.NAME_TOKENIZER_ID=S,exports.NAME_TOKENIZER_ID_DEVNET=A,exports.NftRecord=d,exports.createCollection=async(s,i)=>{const[n]=await e.PublicKey.findProgramAddress([i.toBuffer()],i),[u]=await e.PublicKey.findProgramAddress([l,i.toBuffer()],i),o=m(u),c=k(u),p=await t.getAssociatedTokenAddress(u,n,!0);return[(new a).getInstruction(i,u,c,o,n,p,s,t.TOKEN_PROGRAM_ID,y,e.SystemProgram.programId,r.NAME_PROGRAM_ID,t.ASSOCIATED_TOKEN_PROGRAM_ID,e.SYSVAR_RENT_PUBKEY)]},exports.createCollectionInstruction=a,exports.createMint=async(s,i,r)=>{const[a]=await e.PublicKey.findProgramAddress([r.toBuffer()],r),[u]=await e.PublicKey.findProgramAddress([b,s.toBuffer()],r);return[(new n).getInstruction(r,u,s,a,t.TOKEN_PROGRAM_ID,e.SystemProgram.programId,e.SYSVAR_RENT_PUBKEY,i)]},exports.createMintInstruction=n,exports.createNft=async(s,a,n,o,c,p)=>{const[g]=await e.PublicKey.findProgramAddress([p.toBuffer()],p),[S]=await e.PublicKey.findProgramAddress([b,n.toBuffer()],p),[A]=await d.findKey(n,p),w=await t.getAssociatedTokenAddress(S,o),P=m(S),[W]=await e.PublicKey.findProgramAddress([l,p.toBuffer()],p),[I]=e.PublicKey.findProgramAddressSync([i.Buffer.from(h),y.toBuffer(),W.toBuffer()],y),R=k(W);return[new u({name:s,uri:a}).getInstruction(p,S,w,n,A,o,P,R,I,W,g,c,t.TOKEN_PROGRAM_ID,y,e.SystemProgram.programId,r.NAME_PROGRAM_ID,e.SYSVAR_RENT_PUBKEY,f)]},exports.createNftInstruction=u,exports.editDataInstruction=p,exports.getActiveRecords=async e=>await e.getProgramAccounts(S,{filters:[{memcmp:{offset:0,bytes:"3"}}]}),exports.getMasterEditionPda=k,exports.getMetadataPda=m,exports.getMint=w,exports.getMintFromNameAccount=async(e,s)=>{const i=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:2,bytes:s.toBase58()}}];return await e.getProgramAccounts(S,{filters:i})},exports.getNftForOwner=async(e,s)=>{const i=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:34,bytes:s.toBase58()}}];return await e.getProgramAccounts(S,{filters:i})},exports.getRecordFromMint=async(e,s)=>{const i=[{memcmp:{offset:0,bytes:"3"}},{memcmp:{offset:66,bytes:s.toBase58()}}];return await e.getProgramAccounts(S,{filters:i})},exports.isTokenized=async(e,s)=>{const i=w(s);return 1===(await e.getTokenSupply(i)).value.uiAmount},exports.redeemNft=async(s,i,a)=>{const[n]=await e.PublicKey.findProgramAddress([b,s.toBuffer()],a),[u]=await d.findKey(s,a),c=await t.getAssociatedTokenAddress(n,i);return[(new o).getInstruction(a,n,c,i,u,s,t.TOKEN_PROGRAM_ID,r.NAME_PROGRAM_ID)]},exports.redeemNftInstruction=o,exports.withdrawTokens=async(s,i,r,a,n)=>{const u=await t.getAssociatedTokenAddress(i,r),o=await t.getAssociatedTokenAddress(i,a,!0),p=await t.getAssociatedTokenAddress(s,r);return[(new c).getInstruction(n,p,r,a,u,o,t.TOKEN_PROGRAM_ID,e.SystemProgram.programId)]},exports.withdrawTokensInstruction=c;
